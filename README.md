# Лабораторна робота №9
## Тема: Лямбда-вирази та компаратори
## Виконав(-ли): Ковальчук Станіслав, Сухоручкін Гліб, Янович Марія і Ястремський Богдан
---
### 1. В чому полягають відмінності, переваги та недоліки лямбда-виразів у порівнянні з анонімними класами?
Лямбда-вирази та анонімні класи - це два способи реалізації функціональності в Java, але вони мають різні характеристики та використання. Ось деякі відмінності, переваги та недоліки кожного з них:

**Відмінності:**

 *Синтаксис:*
- Лямбда-вирази мають коротший та більш зручний синтаксис порівняно з анонімними класами.
- Анонімні класи вимагають більше коду та створюють додатковий шум, оскільки потребують оголошення класу та конструктора.

*Об'єм коду:*
- Лямбда-вирази зазвичай зменшують кількість коду і полегшують розуміння, особливо для простих функцій.
- Анонімні класи зазвичай потребують більше коду та можуть ускладнити читання та розуміння коду, особливо якщо потрібно реалізувати інтерфейс або клас з багатьма методами.
  
*Поведінка змінних:*
- Лямбда-вирази мають доступ тільки до фіналізованих або ефективно фіналізованих локальних змінних.
- Анонімні класи можуть мати доступ до будь-яких локальних змінних, навіть якщо вони змінюють своє значення.

**Переваги лямбда-виразів:**
- Коротший синтаксис: Лямбда-вирази мають більш зручний та коротший синтаксис, що полегшує читання та написання коду.
- Зменшення шуму коду: Лямбда-вирази дозволяють зменшити кількість непотрібного коду, такого як оголошення класу та конструктора.
- Підтримка функціональних інтерфейсів: Лямбда-вирази добре поєднуються з функціональними інтерфейсами, що спрощує роботу з потоками, обробниками подій та іншими сценаріями.

**Переваги анонімних класів:**
- Доступ до змінних: Анонімні класи можуть мати доступ до будь-яких локальних змінних, включаючи ті, які змінюють своє значення.
- Підтримка багатьох методів: Анонімні класи можуть реалізувати багато методів, що робить їх корисними для реалізації складних інтерфейсів або класів.

**Недоліки обох методів:**
- Шум коду: Анонімні класи можуть створювати додатковий шум в коді через потребу в оголошенні класу та конструктора.
- Підвищення складності: Використання анонімних класів або лямбда-виразів може підвищити складність коду та зробити його важче для розуміння, особливо для початківців.
- Обмеження Java 7 і нижче: Лямбда-вирази підтримуються тільки в Java 8 і вище, тоді як анонімні класи можна використовувати у всіх версіях Java.

### 2. Що таке функціональний інтерфейс?
Функціональний інтерфейс - це інтерфейс, який містить лише один абстрактний метод. Основна ідея функціональних інтерфейсів полягає в тому, що вони представляють собою контракт для реалізації функцій або лямбда-виразів, які виконують конкретну операцію.

Ось декілька ключових особливостей функціональних інтерфейсів:

- Один абстрактний метод: Функціональний інтерфейс містить лише один абстрактний метод, який описує поведінку, що повинна бути реалізована.
- Можливість використання лямбда-виразів: Оскільки функціональний інтерфейс має тільки один абстрактний метод, його можна використовувати з лямбда-виразами. Це робить код більш компактним та зрозумілим.
- Дефолтні методи та статичні методи: Функціональний інтерфейс може містити дефолтні методи та статичні методи, які надають реалізацію за замовчуванням або додаткові функціональні можливості.

Функціональні інтерфейси широко використовуються в Java в контексті функціонального програмування та в нових функціях, введених в Java 8, таких як Stream API та вбудовані інтерфейси, наприклад Consumer, Predicate, Function тощо. Вони дозволяють передавати функції як аргументи та повертати їх як результати, що робить код більш гнучким та експресивним.

### 3. Що таке статичні та дефолтні методи? Чим вони відрізняються від звичайних методів в інтерфейсах?
Статичні та дефолтні методи - це нові можливості, які були додані в Java 8 для інтерфейсів. Ось їх відмінності та призначення:

**Статичні методи:**
- Статичні методи в інтерфейсах - це методи, які можуть бути викликані без створення екземпляра класу.
- Вони використовуються для надання служб або додаткової функціональності, яка не залежить від конкретної реалізації інтерфейсу.
- Для виклику статичного методу інтерфейсу використовується синтаксис Ім'я_Інтерфейсу.Метод().
- Статичні методи можуть мати реалізацію, але вони не можуть бути перевизначені в класах, що імплементують інтерфейс.

**Дефолтні методи:**
- Дефолтні методи в інтерфейсах - це методи, які мають реалізацію за замовчуванням.
- Вони використовуються для надання реалізації за замовчуванням для методів інтерфейсу, що може бути перевизначено в класах, що імплементують інтерфейс.
- Дефолтні методи в інтерфейсах дозволяють зберегти сумісність з вже існуючими реалізаціями інтерфейсу, не порушуючи принципів "немає руйнувальних змін".
- Для виклику дефолтного методу інтерфейсу використовується синтаксис об'єкт.Метод() або може бути викликаний в самому інтерфейсі.

**Відмінності від звичайних методів в інтерфейсах:**
- Звичайні методи в інтерфейсах не мають реалізації, вони просто оголошуються і обов'язково перевизначаються в класах, що імплементують інтерфейс.
- Статичні та дефолтні методи мають реалізацію за замовчуванням, що може бути використана в класах, які не перевизначають ці методи.

### 4. Чому з лямбда-виразів неможна звертатись до локальних змінних, що змінюють свої значення?

Лямбда-вирази в Java можуть звертатися до локальних змінних, але тільки до таких, які остаточні або ефективно фіналізовані. Однак, лямбда-вирази не можуть звертатися до локальних змінних, які змінюють свої значення після ініціалізації.

Це обмеження існує з двох причин:

- Безпека: Лямбда-вирази виконуються асинхронно, і їхнє виконання може відбуватися пізніше в часі, ніж момент створення. Тому звертання до локальних змінних, які можуть змінюватися після створення лямбди, може призвести до непередбачуваних результатів або помилок в програмі.
- Підтримка паралельних виконань: Використання локальних змінних, що змінюють свої значення, може бути проблематичним у паралельних обчисленнях, так як лямбда-вирази можуть виконуватися в різних потоках одночасно.

Тому, для того щоб зберегти стабільність та передбачуваність поведінки програми, лямбда-вирази в Java мають доступ лише до локальних змінних, які остаточні або ефективно фіналізовані, тобто до тих, які не змінюють свої значення після ініціалізації.

### 5. В чому полягає різниця між поняттями «final» та «effectively final»?
Поняття "final" та "effectively final" використовуються в контексті локальних змінних в Java.

**Final (остаточна) змінна:**
Змінна, оголошена з ключовим словом final, є остаточною.
Остаточні змінні не можуть бути переназначені після ініціалізації. Однак їх значення може змінюватися, якщо це дозволяє тип даних (наприклад, для масивів, значення елементів може змінюватися, але сам масив не може бути переназначений).

**Effectively final (ефективно фіналізована) змінна:**
Змінна, яка не оголошена з ключовим словом final, але не переназначається після ініціалізації, вважається ефективно фіналізованою.
Такі змінні можуть використовуватися всередині лямбда-виразів або анонімних класів в Java 8 і вище.
Вони поводяться подібно до остаточних змінних, оскільки їх значення не змінюється після ініціалізації.

Отже, основна різниця між "final" та "effectively final" полягає в тому, що остаточні змінні є фінальними за своїм станом і не можуть бути змінені, тоді як ефективно фіналізовані змінні, хоча і не оголошені як остаточні, поводяться так само, як остаточні змінні, оскільки їх значення не змінюється після ініціалізації.

---
## **Висновки:** у ході цієї лаборатроної роботи ми здобули нові знання у сфері роботи зі змінними, а також змогли відпрацювати це теоретично та на практиці.
